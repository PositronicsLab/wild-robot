/*
This controller was cloned from the vicon visualization controller after 
refactoring.  It is for rendering a the log generated by a simulation.  It is intended to be used with the camera plugin.  The controller will only replay states that align with the desired movie framerate.  The log file that is read is hardcoded into the controller.
*/
#include <gazebo/gazebo.hh>
#include <gazebo/common/Plugin.hh>
#include <gazebo/common/common.hh>
#include <gazebo/common/Events.hh>
#include <gazebo/physics/physics.hh>

#include "gazebo_log.h"
#include "models.h"
#include "weazelball.h"

#include <stdlib.h>
#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>

#include "movie.h"

#define PI 3.14159265359

#define OUTPUT_FPS 10
double prevframe;
double nextframe;

//-----------------------------------------------------------------------------
/**
The gazebo plugin visualization controller
**/
namespace gazebo 
{
  class controller_c : public ModelPlugin
  {
  private:
    event::ConnectionPtr _updateConnection;  //< Gazebo update callback

    world_ptr _world;                        //< Gazebo world pointer
    weazelball_ptr _weazelball;              //< Weazelball data structure

    wb_vicon_data_ptr _wb_vicon_data;        //< Vicon data structure

    wb_gazebo_session_ptr log;               //< state log
    render_synchronization_buffer_c  rsync;

    double prev_t;
    double frame_dt;
    double state_dt;
    int frame_idx;
    int frame_step;
    int state_idx;
    int state_step;
  public:
    //-------------------------------------------------------------------------
    controller_c( void ) { }

    //-------------------------------------------------------------------------
    virtual ~controller_c( void ) {
      if( log ) log->close();

      event::Events::DisconnectWorldUpdateBegin( _updateConnection );
    }

    //-------------------------------------------------------------------------
    // Gazebo callback.  Called when the simulation is starting up
    virtual void Load( physics::ModelPtr model, sdf::ElementPtr sdf ) {

      state_idx = 0;
      frame_idx = 0;
      std::string validation_errors;
      _world = world_ptr( new world_c( model->GetWorld() ) );
      if( !_world->validate( validation_errors ) ) {
        printf( "Unable to validate world in controller\n%s\nERROR: Plugin failed to load\n", validation_errors.c_str() );
        return;
      }

      _world->reset();

      // get references to objects in the world
      _weazelball = _world->weazelball();
   
      // register update callback
      _updateConnection = event::Events::ConnectWorldUpdateBegin(
        boost::bind( &controller_c::Update, this ) );

      log = wb_gazebo_session_ptr( new wb_gazebo_session_c(wb_gazebo_session_c::READ) );
      if( log->cache("sim.log") ) {
        printf( "ERROR: unable to open gazebo log for reading\nrender controller failed to load\n" );
        exit(1);
        return;
      }
///*
      int r = rsync.open();
      if( r != 0 ) {
        printf("ERROR: rsync open return code %d\n", r );
      }
//*/

      prev_t = 0.0f;
      frame_dt = (double)1.0f / (double)OUTPUT_FPS;
      //state_dt = log->get_dt();
      state_dt = log->get_t(1) - log->get_t(0);
      frame_step = (int)(frame_dt / state_dt);
      state_step = frame_step;

      printf( "states:%d, frame_dt:%f, state_dt:%f, state_step:%d\n", log->size(), frame_dt, state_dt, state_step );
      log->print(0);  printf("\n");
      log->print(1);  printf("\n");
      printf("t(0):%f, t(1):%f\n", log->get_t(0), log->get_t(1));

      // -- FIN --
      printf( "render controller has initialized\n" );   
    }

    //-------------------------------------------------------------------------
    // Gazebo callback.  Called whenever the simulation advances a timestep
    virtual void Update( ) {
      static int update_pass = 1;

      rsync.synchronize( );

      if(update_pass) {
        //printf("Update\n");
        //printf("Synchronized\n");

        //double t;

        log->assign_state( _world, _weazelball, state_idx);
        //t  = log->get_t(state_idx); 

        //prev_t = t;
        state_idx += state_step;
        if(state_idx > log->size()) {
          exit(0);
        }
        update_pass = 0;
      } else {
        rsync.yield_to_render();
        //printf("Done\n");
        update_pass = 1;
      }
    }

  };

  GZ_REGISTER_MODEL_PLUGIN( controller_c )

} // namespace gazebo

//-----------------------------------------------------------------------------

